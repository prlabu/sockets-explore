
I struggled with the environment and compiling C for quite a while. It took me a while to figure out that it wasn't anaconda, but 

I started with C but realized parsing HTTP requests with C can be difficult, and I 


One question that often came up was : when does the TCP three-way handshake take place? From the socket/application perspective, where is that handled? 

I used the PyDocs at https://docs.python.org/3/library/socketserver.html#request-handler-objects for reference in writing the socket


To support persistent HTTP Connections, I realized that I had to keep the handle() method from returning. That is, the full exchange needed to occur within the method. 

One question that I had was whether or not RTT was negligible due to the lack of need to travel over the network. Since everything was developed locally, there is little time required to set up a TCP connection. 

I saw that, in standard HTTP/1.1, the connection parameter in the header can take on two values: keep-alive or close. Keep-alive is actually the standard now. 

I found the socketserver confusing because its 'request' objects don't correspond to HTTP requests; they correspond to new connection requests. 

I am somewhat confused by the fact that all modern browsers use persistent connections by default, but the server codes don't directly support it. 

I decided to give a five second window to the client for keep-alive, in which if there are no HTTP reqs then the connection would be closed. 

The index of the server localhost:8080 is the index.html page, which simply asks the user to make the requests. As such, a user can make requests to the objects via browser. Although this wasn't specified in the assignment, it was helpful for development. It was interesting to see how the browser makes the requests, as I was able to see the server opening and closing TCP connections for each of the .mp3 .jpg and .txt options. 

My biggest bug was adding too many new lines to the HTTP header. So, when the audio or picture file was recieved, it included an extra \n and the file became corrupted. 

I read online at multiple sources that the connection is 'over' on the server side if recv() reads zero bytes. However, I was not able to confirm this. I don't believe this ever occurred in my development.

I encountered trouble in appending the headers and the body. I wasn't sure whether I should be using a buffer or simply appending them as strings. I ended up writing to wfile.

I struggled to figure out how to make handle requests coming asyncronously. That is, the browser (and the client I wrote) make the requests for the files sequentially without waiting for the server to send a response. I briefly investigated the Python 'threading' module but it seemed to be out of my range of coding ability. In the end, I used select() as was demonstrated in lecture. This turned out to be useful in dealing with multiple connections, but didn't nevessarily simplify the multiple-requests-per-connection problem. I also ended up using select() on the client side to know when the socket write/read buffers were reading for the next request.

I realized a potential problem in client-server connections is that the client has now way of knowing which request a response belongs to. For example, if the client requests req1, req2, and req3 within one TCP connection, res3 could arrive first but the client would be expecting res1. 

Additionally, within a single TCP connection, it's difficult to receive requests/responses as single objects. I relaized this when I was reading from the client buffer. I expected to recieve just one response, but in fact recieved 1.5 responses. That is, two HTTP requests were read when I called cli.recieve(). 

One interesting phenomenon that I encountered in testing is that the browser actually never closes the connection, even if it has recieved all of the files dependencies. I found this interesting. This makes me believe that it is more the responsibility of the server to close the TCP connection. Still, I wonder in the real world, who is the manager of the connection?  
Clearly, the server will not keep a connection open in order to conserve resources. Still, from the client perspective, the server may have more information to serve up and the closing the connectin could decrease the performance of the client program. 

I used Python3


References used: 
https://steelkiwi.com/blog/working-tcp-sockets/
https://docs.python.org/3/howto/sockets.html

